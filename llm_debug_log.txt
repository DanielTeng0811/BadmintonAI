
==============================
[2025-12-17 10:03:42] Step: Step 1: Enhancement
------------------------------
[Input Messages]:
  <SYSTEM>

    你是資料分析輔助系統。請分析使用者問題：
    1. 將簡短問題轉化為精準完整的數據分析問題 (Enhanced Prompt)，勿過度詮釋，用繁體中文。
    2. 主題判斷 (Topics): 判斷問題涉及哪些面向，以決定需載入的資料欄位。
       - "spatial": 涉及座標 (x,y)、區域 (area)、落點、移動距離、站位。
       - "score": 涉及得分原因 (win_reason)、失分原因 (lose_reason)、分數狀態 (score)。
       - 若不確定，請列入。若僅需基礎資訊 (rally, player, type)，則留空列表。
    3. 場地資訊 (Needs Court Info): 若涉及 spatial 主題，通常為 true。

    輸出 JSON (No Markdown):
    {
        "enhanced_prompt": "完整的問題",
        "relevant_topics": ["spatial", "score"],
        "needs_court_info": true
    }
    
  <USER>
針對周天成所有「殺球」，繪製其落點熱區圖。

[Output Response]:
{
    "enhanced_prompt": "分析周天成所有殺球的落點，並繪製熱區圖。",
    "relevant_topics": ["spatial"],
    "needs_court_info": true
}
==============================

==============================
[2025-12-17 10:03:55] Step: Step 2: Code Generation
------------------------------
[Input Messages]:
  <SYSTEM>

你是一位羽球數據科學家，任務是分析 pandas DataFrame `df` 並生成 Python 程式碼解決問題，你必須對齊人類的常見邏輯，必要時可新增欄位方便撰寫程式碼，請一步步地思考後再撰寫程式碼。

**規則:**
1. IMPORTANT: 若使用的欄位是代碼，必須圖表中加入圖例(如:"player_type": ，"landing_area"...)
2. 分清楚三種狀態: 主動(得失分)、被動(得失分)或兩者皆有
3. 用 `matplotlib`/`seaborn` 繪圖，最後必須產生 `fig` 物件。勿用 `plt.show()`，且必須確保圖上所有元素不重疊使用(plt.tight_layout())。
4. 勿讀檔 (`df` 已存在)。
5. 計算前驗證數據 (如 `len(df) > 0`)。
6. 類別用名稱。Schema 字串需精確。
7. 用繁體中文。
8. 避免圖表資訊過載 (Information Overload)，保持圖表清晰易讀。
9. 圖表大小、文字與圖片搭配的視覺化需符合常見的圖表展示方式。
10. 若是畫長條圖，可以進行排序，增加識別性。
11. 可使用print()印出重要數值與精簡說明數值意義
11. 若使用 `player_type` 或 `opponent_type` 繪圖，**必須**在輸出中附上數值與名稱的'shot_types'對照表，以便使用者查閱。
12. 若使用area的欄位繪圖(如:player_location_area、landing_area......)，需給予使用者Court Grid Definitions中的Spatial Relationships Matrix
**數據:**
Schema:
[欄位詳細分析報告]
============================================================
### 欄位 'rally'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 42
### 欄位 'ball_round'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 46
### 欄位 'time'- 型態: object- 缺失值: 0% (無缺失)
### 欄位 'frame_num'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 11467.0, 最大值 = 135576.0
### 欄位 'score_status'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -11.0, 最大值 = 10.0
### 欄位 'player_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'opponent_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'player'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'server'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 3.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'type'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['發短球', '長球', '推撲球', '殺球', '接殺防守', '平球', '網前球', '挑球', '切球', '發長球']
### 欄位 'aroundhead'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(0.0), np.float64(1.0)]
### 欄位 'backhand'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(1.0), np.float64(0.0)]
### 欄位 'hit_height'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(2.0), np.float64(1.0)]
### 欄位 'hit_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 24.0
### 欄位 'hit_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7072498108502996, 最大值 = 0.7172898912180071
### 欄位 'hit_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.3553514469433116, 最大值 = 0.9998418761946708
### 欄位 'landing_height'- 型態: float64- ⚠️ 缺失值: 1.90% (99 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(1.0), np.float64(2.0), np.float64(nan)]
### 欄位 'landing_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 33.0
### 欄位 'landing_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.4798500180699032, 最大值 = 1.5145902614586062
### 欄位 'landing_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.5002113337896239, 最大值 = 0.9998418761946708
### 欄位 'lose_reason'- 型態: object- ⚠️ 缺失值: 94.73% (4930 筆)- 唯一值內容: [nan, '出界', '未過網', '掛網', '落點判斷失誤', '犯規']
### 欄位 'win_reason'- 型態: object- ⚠️ 缺失值: 97.18% (5057 筆)- 唯一值內容: [nan, '落地致勝', '落地判斷失誤']
### 欄位 'getpoint_player'- 型態: object- ⚠️ 缺失值: 91.89% (4782 筆)- 唯一值內容: [nan, 'Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'flaw'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'player_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'player_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'player_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'player_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'player_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'opponent_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'opponent_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'opponent_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'opponent_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'opponent_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'ball_distance'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.5661524051776352
### 欄位 'player_type'- 型態: float64- ⚠️ 缺失值: 2.57% (134 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 10.0- 唯一值內容: [np.float64(1.0), np.float64(nan), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(7.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'opponent_type'- 型態: float64- ⚠️ 缺失值: 2.59% (135 筆)- 數值範圍: 最小值 = 0.0, 最大值 = 10.0- 唯一值內容: [np.float64(0.0), np.float64(nan), np.float64(1.0), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(7.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'player_move_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'moving_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'moving_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.999696833101426
### 欄位 'landing_court_number'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'ball_distance_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1092144644472903, 最大值 = 1.330757215969243
### 欄位 'ball_distance_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.13632535323407, 最大值 = 1.2416487645230831
### 欄位 'db'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 0.0- 唯一值內容: [np.float64(0.0)]
### 欄位 'set'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 3- 唯一值內容: [np.int64(1), np.int64(2), np.int64(3)]
### 欄位 'match_id'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 7.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(5.0), np.float64(6.0), np.float64(7.0)]
### 欄位 'rally_id'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0, 最大值 = 475
### 欄位 'opponent'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['CHOU Tien Chen', 'Kento MOMOTA']
定義:
## 比賽資料結構
- Description: 羽球比賽數據欄位定義
- Structure: 三戰兩勝制, 21分制。⚠️ 每局決勝分未記錄，贏家分數需+1。

## 球種代碼對照表
- 1: 發短球
- 2: 發長球
- 3: 長球
- 4: 殺球
- 5: 切球
- 6: 挑球
- 7: 平球
- 8: 網前球
- 9: 推撲球
- 10: 接殺防守
- 11: 接不到

## 欄位定義
### `match_id`: 比賽 ID。用來區分不同的比賽場次。
### `set`: 局數。每場刷新。
### `rally`: 從發球開始到死球結束稱為一個 Rally。這是該局的第幾個 Rally。每局刷新。
- **Usage**: 跨局需配match_id, set。總回合: df.groupby(['match_id', 'set', 'rally']).ngroups
### `rally_id`: 整個數據集中唯一的回合 ID
### `ball_round`: 這是一個 Rally 中的第幾拍。發球是第 1 拍，接發球是第 2 拍，以此類推。
- **Usage**: 若要觀察對手回球、輸球原因等，可使用df['其他特定欄位'].shift()獲取前後拍的資訊
### `player`: 擊球球員姓名
- **Note**: 每個rally中雙方交替擊球
- **Usage**: 與多數欄位同時使用，代表player的各種情況。例如:(df['player']=='Player A' & df['type']=='殺球') -> Player A的殺球
### `opponent`: 對手球員姓名
- **Note**: 每個rally中雙方交替擊球
### `type`: 該球player打出的球種名稱(中文)
- **Note**: 參照shot_types
- **Usage**: 可使用df['type'].shift()獲取前後拍的球種
### `player_type`: 該球player打出的球種代碼
- **Mapping**: 1-11 (見shot_types)
- **Usage**: 若需要對手如何回擊player，參考下一筆的player_type，但必須確保在同個rally中
### `opponent_type`: 等價於該rally前一筆的player_type
- **Mapping**: 1-11 (見shot_types)
- **Note**: 不等價於opponent的回擊球種代碼
### `getpoint_player`: 該回合得分者，若正在打球過程
- **Usage**: group by set/rally取last()，同時欄位有NULL存在，必要時可使用dropna()
- **Important**: 此欄位有三種狀況: player主動得分、player主動失分(當opponent == getpoint_player)與player未得分也未失分(當getpoint_ player==NULL)。
- **Note**: getpoint_player != player不代表player失分，getpoint_player == opponent才代表player失分。
### `hit_x`: player擊球點X座標
### `hit_y`: player擊球點Y座標
### `hit_area`: player擊球點所在區域代碼 (1-32)
### `landing_x`: 球的落點X座標，可視為下顆球對方的擊球點X座標
### `landing_y`: 球的落點Y座標，可視為下顆球對方的擊球點Y座標
### `landing_area`: 球的落點區域代碼 (1-32)(即為下顆球對方的擊球點區域代碼)
### `player_location_x`: 球員所站點的 X 座標。
### `player_location_y`: 球員所站點的 Y 座標。
### `player_location_area`: 球員所站點的區域代碼。
### `player_move_x`: 擊球點到移動位置的X座標位移量。(moving_x-hit_x)
### `player_move_y`: 擊球點到移動位置的Y座標位移量。(moving_y-hit_y)
### `moving_x`: 球員擊完這一球後，移動到的X座標。
### `moving_y`: 球員擊完這一球後，移動到的Y座標。
### `player_moving_area`: 球員擊完這一球後，移動到的區域代碼
### `opponent_location_x`: 對手所站的位置X座標
### `opponent_location_y`: 對手所站的位置Y座標
### `opponent_location_area`: 對手擊球區域。對手所站的位置區域代碼
### `opponent_move_x`: 對手擊球點到移動位置的X座標位移量。
### `opponent_move_y`: 對手擊球點到移動位置的Y座標位移量。
### `ball_distance`: 飛行距離。球從擊球點 (hit) 到落點 (landing) 的直線距離。

## 分析指南
{
  "core": "使用 `getpoint_player` (Event) 統計得分，勿用 `player_score` (State) 加總。",
  "rally_count": "df.groupby(['match_id', 'set', 'rally']).ngroups",
  "winning_logic": {
    "active": "球員(P1)擊球得分: `df[(df['getpoint_player'] == 'P1') & (df['player'] == 'P1')]`",
    "passive": "球員(P1)對手失誤: `df[(df['getpoint_player'] == 'P1') & (df['player'] != 'P1')]`"
  },
  "win_rate": "1.GroupBy Rally取 getpoint_player 2.Sum Wins 3.Divide by total rallies",
  "shot_analysis": {
    "group": "用 `player_type` (數字代碼)",
    "logic": "分析「特定球種得分」時，必須篩選 `player == getpoint_player` (Active Win)。"
  },
  "match_score": "找出每局最後一筆分數，贏家+1。",
  "continuous_play": "回球查詢應用: `iloc` + `index + 1`，注意對手回球是在下一列。"
}

2. **邏輯判斷 (CRITICAL)**:
   - **善用工具箱 (Badminton Toolkit)**: 環境中已預載 `lib` 模組 (from utils import badminton_lib as lib)。**這比你自己寫 Pandas 更準確且省 Token，請優先使用。謹慎注意傳入與回傳的形式**
     - **WARNING**: 呼叫 `lib` 函數時，請務必傳入**完整 DataFrame (df)**，**切勿**先篩選欄位 (e.g., `df[['col1', 'col2']]`)，以免缺少必要欄位導致錯誤。
     - `lib.get_shot_context(df, shift_n=1)`: 獲取前後 N 拍資訊，處理時序分析。輸入 某欄位的DataFrame 與位移量 (+1=setup, -1=response)，回傳含有 suffix 欄位的新 DataFrame。
     - `lib.filter_active_win(df)`: 篩選球員主動得分的回合，排除對手失誤。輸入 DataFrame，回傳過濾後的主動得分 DataFrame。
     - `lib.merge_small_slices(series)`: 合併圓餅圖中佔比過小的區塊。輸入 Series，回傳合併小區塊為「其他」後的 Series。
     - `lib.classify_area(zone_id)`: 將 1-32 的落點代碼轉換為四大場地區域。輸入 Zone ID，回傳前場/中場/後場/出界標籤。
     - `lib.get_win_loss_reason_counts(df, player_name)`: 統計特定球員的得分與失分原因。輸入 DataFrame 與球員名稱，回傳得分原因與失分原因兩個 Series。
     - `lib.get_rally_flow(df, match_id, set_num, rally_id)`: 取得特定 Rally 的完整擊球流程。輸入 Match/Set/Rally ID，回傳依照擊球順序排序的 DataFrame。
     - `lib.get_zones_by_area(area_name)`: 轉換中文場地描述為 Zone ID 列表。輸入區域描述 (如 "前後場")，回傳對應的 Zone ID List (list[int])。

   - **時序分析 (Temporal Analysis)**:
     - 務必使用 `lib.get_shot_context(df, n)`，除特殊情況外，**不要自己寫** `groupby().shift()`。
     - 使用範例:
       ```python
       # 分析周天成殺球後，對手與下一拍的反應
       df_prev = lib.get_shot_context(df, shift_n=-1) 
       df_smash = df_prev[(df_prev['player'] == 'CHOU Tien Chen') & (df_prev['type'] == '殺球')]
       # 分析對手下一拍回球: 欄位變成 'type_next1'
       print(df_smash['type_next1'].value_counts())
       ```
   - IMPORTANT: 主客關係邏輯務必清晰。若該球player='玩家A'為主opponent='玩家A的對手'為客，下一球player='玩家A的對手'為主opponent='玩家A'為客，輪流交替。

3. **視覺化 (Matplotlib/Seaborn)**:
   - 繪製圓餅圖 (Pie Chart) 時，**必須** 使用 `lib.merge_small_slices(data)` 處理數據。
   - 用最適合解決問題的視覺畫圖表呈現(考慮視覺效果，讓圖表更好讀)
   - 必須產生 `fig` 物件，**勿用** `plt.show()`。使用 `plt.tight_layout()` 確保不重疊。
   - 避免資訊過載 (Information Overload)：長條圖可排序/取 Top N；圖表文字需清晰且符合常見展示方式。
   - 若欄位為代碼 (如 `player_type`)，**必須**在圖表中加入圖例。
   - **IMPORTANT**: 不限畫單一圖表，可繪製多張圖表。
   - 「繪圖數據」與「標籤數據」須確保一致。
   - 謹慎使用堆疊長條圖。
   - IMPORTANT: 用繁體中文的圖表標籤

4. **字體設定 (程式碼開頭必寫)**:
```python
import platform
import matplotlib.pyplot as plt
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False
```

**回覆模式 (Strict Format)**:
1. **PLAN 區塊** (必填): 先列出解題邏輯點列 (Pseudocode)，確保邏輯正確。
   e.g.
   PLAN:
   1. Filter data by player...
   2. Use lib.get_shot_context(shift=-1)...
   3. Group by type and count...
2. **PYTHON CODE 區塊**: 接著才是 Python 程式碼。
3. **解釋**: 最後可視情況補充說明。

**回覆範例**:
PLAN:
1. ...
```python
...
```
解釋: ...

**數據 Schema:**
[欄位詳細分析報告]
============================================================
### 欄位 'rally'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 42
### 欄位 'ball_round'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 46
### 欄位 'time'- 型態: object- 缺失值: 0% (無缺失)
### 欄位 'frame_num'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 11467.0, 最大值 = 135576.0
### 欄位 'score_status'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -11.0, 最大值 = 10.0
### 欄位 'player_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'opponent_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'player'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'server'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 3.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'type'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['發短球', '長球', '推撲球', '殺球', '接殺防守', '平球', '網前球', '挑球', '切球', '發長球']
### 欄位 'aroundhead'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(0.0), np.float64(1.0)]
### 欄位 'backhand'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(1.0), np.float64(0.0)]
### 欄位 'hit_height'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(2.0), np.float64(1.0)]
### 欄位 'hit_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 24.0
### 欄位 'hit_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7072498108502996, 最大值 = 0.7172898912180071
### 欄位 'hit_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.3553514469433116, 最大值 = 0.9998418761946708
### 欄位 'landing_height'- 型態: float64- ⚠️ 缺失值: 1.90% (99 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(1.0), np.float64(2.0), np.float64(nan)]
### 欄位 'landing_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 33.0
### 欄位 'landing_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.4798500180699032, 最大值 = 1.5145902614586062
### 欄位 'landing_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.5002113337896239, 最大值 = 0.9998418761946708
### 欄位 'lose_reason'- 型態: object- ⚠️ 缺失值: 94.73% (4930 筆)- 唯一值內容: [nan, '出界', '未過網', '掛網', '落點判斷失誤', '犯規']
### 欄位 'win_reason'- 型態: object- ⚠️ 缺失值: 97.18% (5057 筆)- 唯一值內容: [nan, '落地致勝', '落地判斷失誤']
### 欄位 'getpoint_player'- 型態: object- ⚠️ 缺失值: 91.89% (4782 筆)- 唯一值內容: [nan, 'Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'flaw'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'player_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'player_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'player_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'player_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'player_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'opponent_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'opponent_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'opponent_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'opponent_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'opponent_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'ball_distance'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.5661524051776352
### 欄位 'player_type'- 型態: float64- ⚠️ 缺失值: 2.57% (134 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 10.0- 唯一值內容: [np.float64(1.0), np.float64(nan), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(7.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'opponent_type'- 型態: float64- ⚠️ 缺失值: 2.59% (135 筆)- 數值範圍: 最小值 = 0.0, 最大值 = 10.0- 唯一值內容: [np.float64(0.0), np.float64(nan), np.float64(1.0), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(7.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'player_move_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'moving_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'moving_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.999696833101426
### 欄位 'landing_court_number'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'ball_distance_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1092144644472903, 最大值 = 1.330757215969243
### 欄位 'ball_distance_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.13632535323407, 最大值 = 1.2416487645230831
### 欄位 'db'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 0.0- 唯一值內容: [np.float64(0.0)]
### 欄位 'set'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 3- 唯一值內容: [np.int64(1), np.int64(2), np.int64(3)]
### 欄位 'match_id'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 7.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(5.0), np.float64(6.0), np.float64(7.0)]
### 欄位 'rally_id'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0, 最大值 = 475
### 欄位 'opponent'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['CHOU Tien Chen', 'Kento MOMOTA']

**欄位定義:**
## 比賽資料結構
- Description: 羽球比賽數據欄位定義
- Structure: 三戰兩勝制, 21分制。⚠️ 每局決勝分未記錄，贏家分數需+1。

## 球種代碼對照表
- 1: 發短球
- 2: 發長球
- 3: 長球
- 4: 殺球
- 5: 切球
- 6: 挑球
- 7: 平球
- 8: 網前球
- 9: 推撲球
- 10: 接殺防守
- 11: 接不到

## 欄位定義
### `match_id`: 比賽 ID。用來區分不同的比賽場次。
### `set`: 局數。每場刷新。
### `rally`: 從發球開始到死球結束稱為一個 Rally。這是該局的第幾個 Rally。每局刷新。
- **Usage**: 跨局需配match_id, set。總回合: df.groupby(['match_id', 'set', 'rally']).ngroups
### `rally_id`: 整個數據集中唯一的回合 ID
### `ball_round`: 這是一個 Rally 中的第幾拍。發球是第 1 拍，接發球是第 2 拍，以此類推。
- **Usage**: 若要觀察對手回球、輸球原因等，可使用df['其他特定欄位'].shift()獲取前後拍的資訊
### `player`: 擊球球員姓名
- **Note**: 每個rally中雙方交替擊球
- **Usage**: 與多數欄位同時使用，代表player的各種情況。例如:(df['player']=='Player A' & df['type']=='殺球') -> Player A的殺球
### `opponent`: 對手球員姓名
- **Note**: 每個rally中雙方交替擊球
### `type`: 該球player打出的球種名稱(中文)
- **Note**: 參照shot_types
- **Usage**: 可使用df['type'].shift()獲取前後拍的球種
### `player_type`: 該球player打出的球種代碼
- **Mapping**: 1-11 (見shot_types)
- **Usage**: 若需要對手如何回擊player，參考下一筆的player_type，但必須確保在同個rally中
### `opponent_type`: 等價於該rally前一筆的player_type
- **Mapping**: 1-11 (見shot_types)
- **Note**: 不等價於opponent的回擊球種代碼
### `getpoint_player`: 該回合得分者，若正在打球過程
- **Usage**: group by set/rally取last()，同時欄位有NULL存在，必要時可使用dropna()
- **Important**: 此欄位有三種狀況: player主動得分、player主動失分(當opponent == getpoint_player)與player未得分也未失分(當getpoint_ player==NULL)。
- **Note**: getpoint_player != player不代表player失分，getpoint_player == opponent才代表player失分。
### `hit_x`: player擊球點X座標
### `hit_y`: player擊球點Y座標
### `hit_area`: player擊球點所在區域代碼 (1-32)
### `landing_x`: 球的落點X座標，可視為下顆球對方的擊球點X座標
### `landing_y`: 球的落點Y座標，可視為下顆球對方的擊球點Y座標
### `landing_area`: 球的落點區域代碼 (1-32)(即為下顆球對方的擊球點區域代碼)
### `player_location_x`: 球員所站點的 X 座標。
### `player_location_y`: 球員所站點的 Y 座標。
### `player_location_area`: 球員所站點的區域代碼。
### `player_move_x`: 擊球點到移動位置的X座標位移量。(moving_x-hit_x)
### `player_move_y`: 擊球點到移動位置的Y座標位移量。(moving_y-hit_y)
### `moving_x`: 球員擊完這一球後，移動到的X座標。
### `moving_y`: 球員擊完這一球後，移動到的Y座標。
### `player_moving_area`: 球員擊完這一球後，移動到的區域代碼
### `opponent_location_x`: 對手所站的位置X座標
### `opponent_location_y`: 對手所站的位置Y座標
### `opponent_location_area`: 對手擊球區域。對手所站的位置區域代碼
### `opponent_move_x`: 對手擊球點到移動位置的X座標位移量。
### `opponent_move_y`: 對手擊球點到移動位置的Y座標位移量。
### `ball_distance`: 飛行距離。球從擊球點 (hit) 到落點 (landing) 的直線距離。

## 分析指南
{
  "core": "使用 `getpoint_player` (Event) 統計得分，勿用 `player_score` (State) 加總。",
  "rally_count": "df.groupby(['match_id', 'set', 'rally']).ngroups",
  "winning_logic": {
    "active": "球員(P1)擊球得分: `df[(df['getpoint_player'] == 'P1') & (df['player'] == 'P1')]`",
    "passive": "球員(P1)對手失誤: `df[(df['getpoint_player'] == 'P1') & (df['player'] != 'P1')]`"
  },
  "win_rate": "1.GroupBy Rally取 getpoint_player 2.Sum Wins 3.Divide by total rallies",
  "shot_analysis": {
    "group": "用 `player_type` (數字代碼)",
    "logic": "分析「特定球種得分」時，必須篩選 `player == getpoint_player` (Active Win)。"
  },
  "match_score": "找出每局最後一筆分數，贏家+1。",
  "continuous_play": "回球查詢應用: `iloc` + `index + 1`，注意對手回球是在下一列。"
}


**場地位置參考資訊 (Court Grid Definitions):**
# Role Definition
You are an expert Badminton Tactical Analyst. You interpret court positions based on a specific discretized grid layout of a half-court.

# Court Grid Definitions
The badminton half-court is divided into a grid system with specific Zone IDs (1-32).

## 1. Zone Categories (Semantic Layers)
* **Front Court (前排 - Net Area):** Zones [17, 18, 19, 20, 21, 22, 23, 24]
    * *Sub-divided into 2 rows:*
        * Row M2 (the net area): 21, 22, 23, 24
        * Row M1: 17, 18, 19, 20
* **Mid Court (中排 - Midfield):** Zones [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    * *Sub-divided into 3 rows:*
        * Row M3 (Front-Mid): 13, 14, 15, 16
        * Row M2: 9, 10, 11, 12
        * Row M1 (Back-Mid): 5, 6, 7, 8
* **Back Court (後排 - Baseline Area):** Zones [1, 2, 3, 4]
    * *Defensive area, clears and smashes originate here.*
* **Out of Bounds (出界區域):**
    * Left Flank (Left Side Out): 31 (Bottom), 30 (Mid), 29 (Top)
    * Right Flank (Right Side Out): 27 (Bottom), 26 (Mid), 25 (Top)
    * Rear Out (Behind Baseline): 32 (Left-Back), 28 (Right-Back)

## 2. Spatial Relationships (The Grid Matrix)
Imagine the court as a Matrix where Row 1 is the back (baseline) and Row 6 is the front (net).
Columns go from Left (A) to Right (D).

| Row/Col | Col A (Left) | Col B (Center-Left) | Col C (Center-Right) | Col D (Right) |
| :--- | :---: | :---: | :---: | :---: |
| **Row 6 (Front)** | 21 | 22 | 23 | 24 |
| **Row 5 (Front)** | 17 | 18 | 19 | 20 |
| **Row 4 (Mid)** | 13 | 14 | 15 | 16 |
| **Row 3 (Mid)** | 9 | 10 | 11 | 12 |
| **Row 2 (Mid)** | 5 | 6 | 7 | 8 |
| **Row 1 (Back)** | 1 | 2 | 3 | 4 |

*Note: Zones 29-31 are to the left of Col A. Zones 25-27 are to the right of Col D.*

## 3. Logic Rules for Analysis
1.  **Movement logic:** Moving from Zone 6 to Zone 10 is a "Forward" movement. Moving from 10 to 6 is "Backward".
2.  **Left/Right logic:** Zone 5 is "Left" of Zone 6. Zone 8 is the "Rightmost" in its row.
3.  **Adjacency:**
    * Zone 1 is adjacent to [2, 5, 31, 32].
    * Zone 14 is adjacent to [13, 15, 10, 18].
    * Zone 24 (Front-Right) is adjacent to [23, 20, 25].

# Task
When I provide a Zone ID, tell me its:
1.  **Category** (Front/Mid/Back/Out)
2.  **Relative Position** (e.g., Front-Left, Mid-Center)

    
**最佳實踐:**
    1. 區分連續數值(Float)與類別。座標勿直接 groupby。
    2. 軸標籤避免大量浮點數。
    3. 繪圖前檢查 `if len(filtered_df) > 0:`。
    
  <USER>
分析周天成所有殺球的落點，並繪製熱區圖。

[Output Response]:
PLAN:
1. 篩選出 `player` 為 "CHOU Tien Chen" 且 `type` 為 "殺球" 的數據。
2. 使用 `landing_area` 確定殺球的落點。
3. 確認數據存在。
4. 繪製場地區域熱區圖，顯示每個區域的殺球數量。

```python
import platform
import matplotlib.pyplot as plt
import seaborn as sns

# 字體設定
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False

# 篩選出周天成的殺球記錄
smash_df = df[(df['player'] == 'CHOU Tien Chen') & (df['type'] == '殺球')]

# 確認數據存在
if len(smash_df) > 0:
    # 統計每個區域的殺球落點數量
    landing_counts = smash_df['landing_area'].value_counts().sort_index()

    # 轉換區域代碼為熱區圖所需的格式
    grid_matrix = np.zeros((6, 4))
    for area, count in landing_counts.items():
        # 獲得區域的行列位置 (注意區域編碼從1開始)
        row = 6 - (area - 1) // 4
        col = (area - 1) % 4
        grid_matrix[row - 1, col] = count

    # 繪製熱區圖
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(grid_matrix, annot=True, fmt=".0f", cmap='Reds', ax=ax, cbar_kws={'label': '殺球次數'})
    ax.set_title('周天成殺球落點熱區圖')
    ax.set_xlabel('列 (從左到右)')
    ax.set_ylabel('行 (從後排到前排)')
    ax.set_yticklabels(['後排', '中排3', '中排2', '中排1', '前排2', '前排1'], rotation=0)
    ax.set_xticklabels(['左', '中左', '中右', '右'])
    plt.tight_layout()
else:
    print("周天成沒有任何殺球記錄。")
```

解釋:
- 這段程式碼首先篩選出周天成的所有殺球記錄。
- 然後根據落點區域的編碼填充6x4的矩陣，每個單元格表示一個場地區域。
- 使用Seaborn的`heatmap`來繪製殺球落點的熱區圖，並標註每個區域的殺球次數。
- 圖中行的標籤從後排（1行）到前排（6行），列的標籤從左到右，與場地分布對應。
==============================

==============================
[2025-12-17 10:04:05] Step: Step 3: Error Fix (Retry 1)
------------------------------
[Input Messages]:
  <SYSTEM>

你是一位羽球數據科學家，任務是分析 pandas DataFrame `df` 並生成 Python 程式碼解決問題，你必須對齊人類的常見邏輯，必要時可新增欄位方便撰寫程式碼，請一步步地思考後再撰寫程式碼。

**規則:**
1. IMPORTANT: 若使用的欄位是代碼，必須圖表中加入圖例(如:"player_type": ，"landing_area"...)
2. 分清楚三種狀態: 主動(得失分)、被動(得失分)或兩者皆有
3. 用 `matplotlib`/`seaborn` 繪圖，最後必須產生 `fig` 物件。勿用 `plt.show()`，且必須確保圖上所有元素不重疊使用(plt.tight_layout())。
4. 勿讀檔 (`df` 已存在)。
5. 計算前驗證數據 (如 `len(df) > 0`)。
6. 類別用名稱。Schema 字串需精確。
7. 用繁體中文。
8. 避免圖表資訊過載 (Information Overload)，保持圖表清晰易讀。
9. 圖表大小、文字與圖片搭配的視覺化需符合常見的圖表展示方式。
10. 若是畫長條圖，可以進行排序，增加識別性。
11. 可使用print()印出重要數值與精簡說明數值意義
11. 若使用 `player_type` 或 `opponent_type` 繪圖，**必須**在輸出中附上數值與名稱的'shot_types'對照表，以便使用者查閱。
12. 若使用area的欄位繪圖(如:player_location_area、landing_area......)，需給予使用者Court Grid Definitions中的Spatial Relationships Matrix
**數據:**
Schema:
[欄位詳細分析報告]
============================================================
### 欄位 'rally'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 42
### 欄位 'ball_round'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 46
### 欄位 'time'- 型態: object- 缺失值: 0% (無缺失)
### 欄位 'frame_num'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 11467.0, 最大值 = 135576.0
### 欄位 'score_status'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -11.0, 最大值 = 10.0
### 欄位 'player_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'opponent_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'player'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'server'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 3.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'type'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['發短球', '長球', '推撲球', '殺球', '接殺防守', '平球', '網前球', '挑球', '切球', '發長球']
### 欄位 'aroundhead'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(0.0), np.float64(1.0)]
### 欄位 'backhand'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(1.0), np.float64(0.0)]
### 欄位 'hit_height'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(2.0), np.float64(1.0)]
### 欄位 'hit_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 24.0
### 欄位 'hit_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7072498108502996, 最大值 = 0.7172898912180071
### 欄位 'hit_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.3553514469433116, 最大值 = 0.9998418761946708
### 欄位 'landing_height'- 型態: float64- ⚠️ 缺失值: 1.90% (99 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(1.0), np.float64(2.0), np.float64(nan)]
### 欄位 'landing_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 33.0
### 欄位 'landing_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.4798500180699032, 最大值 = 1.5145902614586062
### 欄位 'landing_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.5002113337896239, 最大值 = 0.9998418761946708
### 欄位 'lose_reason'- 型態: object- ⚠️ 缺失值: 94.73% (4930 筆)- 唯一值內容: [nan, '出界', '未過網', '掛網', '落點判斷失誤', '犯規']
### 欄位 'win_reason'- 型態: object- ⚠️ 缺失值: 97.18% (5057 筆)- 唯一值內容: [nan, '落地致勝', '落地判斷失誤']
### 欄位 'getpoint_player'- 型態: object- ⚠️ 缺失值: 91.89% (4782 筆)- 唯一值內容: [nan, 'Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'flaw'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'player_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'player_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'player_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'player_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'player_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'opponent_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'opponent_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'opponent_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'opponent_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'opponent_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'ball_distance'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.5661524051776352
### 欄位 'player_type'- 型態: float64- ⚠️ 缺失值: 2.57% (134 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 10.0- 唯一值內容: [np.float64(1.0), np.float64(nan), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(7.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'opponent_type'- 型態: float64- ⚠️ 缺失值: 2.59% (135 筆)- 數值範圍: 最小值 = 0.0, 最大值 = 10.0- 唯一值內容: [np.float64(0.0), np.float64(nan), np.float64(1.0), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(7.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'player_move_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'moving_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'moving_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.999696833101426
### 欄位 'landing_court_number'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'ball_distance_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1092144644472903, 最大值 = 1.330757215969243
### 欄位 'ball_distance_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.13632535323407, 最大值 = 1.2416487645230831
### 欄位 'db'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 0.0- 唯一值內容: [np.float64(0.0)]
### 欄位 'set'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 3- 唯一值內容: [np.int64(1), np.int64(2), np.int64(3)]
### 欄位 'match_id'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 7.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(5.0), np.float64(6.0), np.float64(7.0)]
### 欄位 'rally_id'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0, 最大值 = 475
### 欄位 'opponent'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['CHOU Tien Chen', 'Kento MOMOTA']
定義:
## 比賽資料結構
- Description: 羽球比賽數據欄位定義
- Structure: 三戰兩勝制, 21分制。⚠️ 每局決勝分未記錄，贏家分數需+1。

## 球種代碼對照表
- 1: 發短球
- 2: 發長球
- 3: 長球
- 4: 殺球
- 5: 切球
- 6: 挑球
- 7: 平球
- 8: 網前球
- 9: 推撲球
- 10: 接殺防守
- 11: 接不到

## 欄位定義
### `match_id`: 比賽 ID。用來區分不同的比賽場次。
### `set`: 局數。每場刷新。
### `rally`: 從發球開始到死球結束稱為一個 Rally。這是該局的第幾個 Rally。每局刷新。
- **Usage**: 跨局需配match_id, set。總回合: df.groupby(['match_id', 'set', 'rally']).ngroups
### `rally_id`: 整個數據集中唯一的回合 ID
### `ball_round`: 這是一個 Rally 中的第幾拍。發球是第 1 拍，接發球是第 2 拍，以此類推。
- **Usage**: 若要觀察對手回球、輸球原因等，可使用df['其他特定欄位'].shift()獲取前後拍的資訊
### `player`: 擊球球員姓名
- **Note**: 每個rally中雙方交替擊球
- **Usage**: 與多數欄位同時使用，代表player的各種情況。例如:(df['player']=='Player A' & df['type']=='殺球') -> Player A的殺球
### `opponent`: 對手球員姓名
- **Note**: 每個rally中雙方交替擊球
### `type`: 該球player打出的球種名稱(中文)
- **Note**: 參照shot_types
- **Usage**: 可使用df['type'].shift()獲取前後拍的球種
### `player_type`: 該球player打出的球種代碼
- **Mapping**: 1-11 (見shot_types)
- **Usage**: 若需要對手如何回擊player，參考下一筆的player_type，但必須確保在同個rally中
### `opponent_type`: 等價於該rally前一筆的player_type
- **Mapping**: 1-11 (見shot_types)
- **Note**: 不等價於opponent的回擊球種代碼
### `getpoint_player`: 該回合得分者，若正在打球過程
- **Usage**: group by set/rally取last()，同時欄位有NULL存在，必要時可使用dropna()
- **Important**: 此欄位有三種狀況: player主動得分、player主動失分(當opponent == getpoint_player)與player未得分也未失分(當getpoint_ player==NULL)。
- **Note**: getpoint_player != player不代表player失分，getpoint_player == opponent才代表player失分。
### `hit_x`: player擊球點X座標
### `hit_y`: player擊球點Y座標
### `hit_area`: player擊球點所在區域代碼 (1-32)
### `landing_x`: 球的落點X座標，可視為下顆球對方的擊球點X座標
### `landing_y`: 球的落點Y座標，可視為下顆球對方的擊球點Y座標
### `landing_area`: 球的落點區域代碼 (1-32)(即為下顆球對方的擊球點區域代碼)
### `player_location_x`: 球員所站點的 X 座標。
### `player_location_y`: 球員所站點的 Y 座標。
### `player_location_area`: 球員所站點的區域代碼。
### `player_move_x`: 擊球點到移動位置的X座標位移量。(moving_x-hit_x)
### `player_move_y`: 擊球點到移動位置的Y座標位移量。(moving_y-hit_y)
### `moving_x`: 球員擊完這一球後，移動到的X座標。
### `moving_y`: 球員擊完這一球後，移動到的Y座標。
### `player_moving_area`: 球員擊完這一球後，移動到的區域代碼
### `opponent_location_x`: 對手所站的位置X座標
### `opponent_location_y`: 對手所站的位置Y座標
### `opponent_location_area`: 對手擊球區域。對手所站的位置區域代碼
### `opponent_move_x`: 對手擊球點到移動位置的X座標位移量。
### `opponent_move_y`: 對手擊球點到移動位置的Y座標位移量。
### `ball_distance`: 飛行距離。球從擊球點 (hit) 到落點 (landing) 的直線距離。

## 分析指南
{
  "core": "使用 `getpoint_player` (Event) 統計得分，勿用 `player_score` (State) 加總。",
  "rally_count": "df.groupby(['match_id', 'set', 'rally']).ngroups",
  "winning_logic": {
    "active": "球員(P1)擊球得分: `df[(df['getpoint_player'] == 'P1') & (df['player'] == 'P1')]`",
    "passive": "球員(P1)對手失誤: `df[(df['getpoint_player'] == 'P1') & (df['player'] != 'P1')]`"
  },
  "win_rate": "1.GroupBy Rally取 getpoint_player 2.Sum Wins 3.Divide by total rallies",
  "shot_analysis": {
    "group": "用 `player_type` (數字代碼)",
    "logic": "分析「特定球種得分」時，必須篩選 `player == getpoint_player` (Active Win)。"
  },
  "match_score": "找出每局最後一筆分數，贏家+1。",
  "continuous_play": "回球查詢應用: `iloc` + `index + 1`，注意對手回球是在下一列。"
}

2. **邏輯判斷 (CRITICAL)**:
   - **善用工具箱 (Badminton Toolkit)**: 環境中已預載 `lib` 模組 (from utils import badminton_lib as lib)。**這比你自己寫 Pandas 更準確且省 Token，請優先使用。謹慎注意傳入與回傳的形式**
     - **WARNING**: 呼叫 `lib` 函數時，請務必傳入**完整 DataFrame (df)**，**切勿**先篩選欄位 (e.g., `df[['col1', 'col2']]`)，以免缺少必要欄位導致錯誤。
     - `lib.get_shot_context(df, shift_n=1)`: 獲取前後 N 拍資訊，處理時序分析。輸入 某欄位的DataFrame 與位移量 (+1=setup, -1=response)，回傳含有 suffix 欄位的新 DataFrame。
     - `lib.filter_active_win(df)`: 篩選球員主動得分的回合，排除對手失誤。輸入 DataFrame，回傳過濾後的主動得分 DataFrame。
     - `lib.merge_small_slices(series)`: 合併圓餅圖中佔比過小的區塊。輸入 Series，回傳合併小區塊為「其他」後的 Series。
     - `lib.classify_area(zone_id)`: 將 1-32 的落點代碼轉換為四大場地區域。輸入 Zone ID，回傳前場/中場/後場/出界標籤。
     - `lib.get_win_loss_reason_counts(df, player_name)`: 統計特定球員的得分與失分原因。輸入 DataFrame 與球員名稱，回傳得分原因與失分原因兩個 Series。
     - `lib.get_rally_flow(df, match_id, set_num, rally_id)`: 取得特定 Rally 的完整擊球流程。輸入 Match/Set/Rally ID，回傳依照擊球順序排序的 DataFrame。
     - `lib.get_zones_by_area(area_name)`: 轉換中文場地描述為 Zone ID 列表。輸入區域描述 (如 "前後場")，回傳對應的 Zone ID List (list[int])。

   - **時序分析 (Temporal Analysis)**:
     - 務必使用 `lib.get_shot_context(df, n)`，除特殊情況外，**不要自己寫** `groupby().shift()`。
     - 使用範例:
       ```python
       # 分析周天成殺球後，對手與下一拍的反應
       df_prev = lib.get_shot_context(df, shift_n=-1) 
       df_smash = df_prev[(df_prev['player'] == 'CHOU Tien Chen') & (df_prev['type'] == '殺球')]
       # 分析對手下一拍回球: 欄位變成 'type_next1'
       print(df_smash['type_next1'].value_counts())
       ```
   - IMPORTANT: 主客關係邏輯務必清晰。若該球player='玩家A'為主opponent='玩家A的對手'為客，下一球player='玩家A的對手'為主opponent='玩家A'為客，輪流交替。

3. **視覺化 (Matplotlib/Seaborn)**:
   - 繪製圓餅圖 (Pie Chart) 時，**必須** 使用 `lib.merge_small_slices(data)` 處理數據。
   - 用最適合解決問題的視覺畫圖表呈現(考慮視覺效果，讓圖表更好讀)
   - 必須產生 `fig` 物件，**勿用** `plt.show()`。使用 `plt.tight_layout()` 確保不重疊。
   - 避免資訊過載 (Information Overload)：長條圖可排序/取 Top N；圖表文字需清晰且符合常見展示方式。
   - 若欄位為代碼 (如 `player_type`)，**必須**在圖表中加入圖例。
   - **IMPORTANT**: 不限畫單一圖表，可繪製多張圖表。
   - 「繪圖數據」與「標籤數據」須確保一致。
   - 謹慎使用堆疊長條圖。
   - IMPORTANT: 用繁體中文的圖表標籤

4. **字體設定 (程式碼開頭必寫)**:
```python
import platform
import matplotlib.pyplot as plt
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False
```

**回覆模式 (Strict Format)**:
1. **PLAN 區塊** (必填): 先列出解題邏輯點列 (Pseudocode)，確保邏輯正確。
   e.g.
   PLAN:
   1. Filter data by player...
   2. Use lib.get_shot_context(shift=-1)...
   3. Group by type and count...
2. **PYTHON CODE 區塊**: 接著才是 Python 程式碼。
3. **解釋**: 最後可視情況補充說明。

**回覆範例**:
PLAN:
1. ...
```python
...
```
解釋: ...

**數據 Schema:**
[欄位詳細分析報告]
============================================================
### 欄位 'rally'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 42
### 欄位 'ball_round'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 46
### 欄位 'time'- 型態: object- 缺失值: 0% (無缺失)
### 欄位 'frame_num'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 11467.0, 最大值 = 135576.0
### 欄位 'score_status'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -11.0, 最大值 = 10.0
### 欄位 'player_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'opponent_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'player'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'server'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 3.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'type'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['發短球', '長球', '推撲球', '殺球', '接殺防守', '平球', '網前球', '挑球', '切球', '發長球']
### 欄位 'aroundhead'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(0.0), np.float64(1.0)]
### 欄位 'backhand'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(1.0), np.float64(0.0)]
### 欄位 'hit_height'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(2.0), np.float64(1.0)]
### 欄位 'hit_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 24.0
### 欄位 'hit_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7072498108502996, 最大值 = 0.7172898912180071
### 欄位 'hit_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.3553514469433116, 最大值 = 0.9998418761946708
### 欄位 'landing_height'- 型態: float64- ⚠️ 缺失值: 1.90% (99 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(1.0), np.float64(2.0), np.float64(nan)]
### 欄位 'landing_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 33.0
### 欄位 'landing_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.4798500180699032, 最大值 = 1.5145902614586062
### 欄位 'landing_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.5002113337896239, 最大值 = 0.9998418761946708
### 欄位 'lose_reason'- 型態: object- ⚠️ 缺失值: 94.73% (4930 筆)- 唯一值內容: [nan, '出界', '未過網', '掛網', '落點判斷失誤', '犯規']
### 欄位 'win_reason'- 型態: object- ⚠️ 缺失值: 97.18% (5057 筆)- 唯一值內容: [nan, '落地致勝', '落地判斷失誤']
### 欄位 'getpoint_player'- 型態: object- ⚠️ 缺失值: 91.89% (4782 筆)- 唯一值內容: [nan, 'Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'flaw'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'player_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'player_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'player_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'player_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'player_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'opponent_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'opponent_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'opponent_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'opponent_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'opponent_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'ball_distance'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.5661524051776352
### 欄位 'player_type'- 型態: float64- ⚠️ 缺失值: 2.57% (134 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 10.0- 唯一值內容: [np.float64(1.0), np.float64(nan), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(7.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'opponent_type'- 型態: float64- ⚠️ 缺失值: 2.59% (135 筆)- 數值範圍: 最小值 = 0.0, 最大值 = 10.0- 唯一值內容: [np.float64(0.0), np.float64(nan), np.float64(1.0), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(7.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'player_move_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'moving_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'moving_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.999696833101426
### 欄位 'landing_court_number'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'ball_distance_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1092144644472903, 最大值 = 1.330757215969243
### 欄位 'ball_distance_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.13632535323407, 最大值 = 1.2416487645230831
### 欄位 'db'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 0.0- 唯一值內容: [np.float64(0.0)]
### 欄位 'set'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 3- 唯一值內容: [np.int64(1), np.int64(2), np.int64(3)]
### 欄位 'match_id'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 7.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(5.0), np.float64(6.0), np.float64(7.0)]
### 欄位 'rally_id'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0, 最大值 = 475
### 欄位 'opponent'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['CHOU Tien Chen', 'Kento MOMOTA']

**欄位定義:**
## 比賽資料結構
- Description: 羽球比賽數據欄位定義
- Structure: 三戰兩勝制, 21分制。⚠️ 每局決勝分未記錄，贏家分數需+1。

## 球種代碼對照表
- 1: 發短球
- 2: 發長球
- 3: 長球
- 4: 殺球
- 5: 切球
- 6: 挑球
- 7: 平球
- 8: 網前球
- 9: 推撲球
- 10: 接殺防守
- 11: 接不到

## 欄位定義
### `match_id`: 比賽 ID。用來區分不同的比賽場次。
### `set`: 局數。每場刷新。
### `rally`: 從發球開始到死球結束稱為一個 Rally。這是該局的第幾個 Rally。每局刷新。
- **Usage**: 跨局需配match_id, set。總回合: df.groupby(['match_id', 'set', 'rally']).ngroups
### `rally_id`: 整個數據集中唯一的回合 ID
### `ball_round`: 這是一個 Rally 中的第幾拍。發球是第 1 拍，接發球是第 2 拍，以此類推。
- **Usage**: 若要觀察對手回球、輸球原因等，可使用df['其他特定欄位'].shift()獲取前後拍的資訊
### `player`: 擊球球員姓名
- **Note**: 每個rally中雙方交替擊球
- **Usage**: 與多數欄位同時使用，代表player的各種情況。例如:(df['player']=='Player A' & df['type']=='殺球') -> Player A的殺球
### `opponent`: 對手球員姓名
- **Note**: 每個rally中雙方交替擊球
### `type`: 該球player打出的球種名稱(中文)
- **Note**: 參照shot_types
- **Usage**: 可使用df['type'].shift()獲取前後拍的球種
### `player_type`: 該球player打出的球種代碼
- **Mapping**: 1-11 (見shot_types)
- **Usage**: 若需要對手如何回擊player，參考下一筆的player_type，但必須確保在同個rally中
### `opponent_type`: 等價於該rally前一筆的player_type
- **Mapping**: 1-11 (見shot_types)
- **Note**: 不等價於opponent的回擊球種代碼
### `getpoint_player`: 該回合得分者，若正在打球過程
- **Usage**: group by set/rally取last()，同時欄位有NULL存在，必要時可使用dropna()
- **Important**: 此欄位有三種狀況: player主動得分、player主動失分(當opponent == getpoint_player)與player未得分也未失分(當getpoint_ player==NULL)。
- **Note**: getpoint_player != player不代表player失分，getpoint_player == opponent才代表player失分。
### `hit_x`: player擊球點X座標
### `hit_y`: player擊球點Y座標
### `hit_area`: player擊球點所在區域代碼 (1-32)
### `landing_x`: 球的落點X座標，可視為下顆球對方的擊球點X座標
### `landing_y`: 球的落點Y座標，可視為下顆球對方的擊球點Y座標
### `landing_area`: 球的落點區域代碼 (1-32)(即為下顆球對方的擊球點區域代碼)
### `player_location_x`: 球員所站點的 X 座標。
### `player_location_y`: 球員所站點的 Y 座標。
### `player_location_area`: 球員所站點的區域代碼。
### `player_move_x`: 擊球點到移動位置的X座標位移量。(moving_x-hit_x)
### `player_move_y`: 擊球點到移動位置的Y座標位移量。(moving_y-hit_y)
### `moving_x`: 球員擊完這一球後，移動到的X座標。
### `moving_y`: 球員擊完這一球後，移動到的Y座標。
### `player_moving_area`: 球員擊完這一球後，移動到的區域代碼
### `opponent_location_x`: 對手所站的位置X座標
### `opponent_location_y`: 對手所站的位置Y座標
### `opponent_location_area`: 對手擊球區域。對手所站的位置區域代碼
### `opponent_move_x`: 對手擊球點到移動位置的X座標位移量。
### `opponent_move_y`: 對手擊球點到移動位置的Y座標位移量。
### `ball_distance`: 飛行距離。球從擊球點 (hit) 到落點 (landing) 的直線距離。

## 分析指南
{
  "core": "使用 `getpoint_player` (Event) 統計得分，勿用 `player_score` (State) 加總。",
  "rally_count": "df.groupby(['match_id', 'set', 'rally']).ngroups",
  "winning_logic": {
    "active": "球員(P1)擊球得分: `df[(df['getpoint_player'] == 'P1') & (df['player'] == 'P1')]`",
    "passive": "球員(P1)對手失誤: `df[(df['getpoint_player'] == 'P1') & (df['player'] != 'P1')]`"
  },
  "win_rate": "1.GroupBy Rally取 getpoint_player 2.Sum Wins 3.Divide by total rallies",
  "shot_analysis": {
    "group": "用 `player_type` (數字代碼)",
    "logic": "分析「特定球種得分」時，必須篩選 `player == getpoint_player` (Active Win)。"
  },
  "match_score": "找出每局最後一筆分數，贏家+1。",
  "continuous_play": "回球查詢應用: `iloc` + `index + 1`，注意對手回球是在下一列。"
}


**場地位置參考資訊 (Court Grid Definitions):**
# Role Definition
You are an expert Badminton Tactical Analyst. You interpret court positions based on a specific discretized grid layout of a half-court.

# Court Grid Definitions
The badminton half-court is divided into a grid system with specific Zone IDs (1-32).

## 1. Zone Categories (Semantic Layers)
* **Front Court (前排 - Net Area):** Zones [17, 18, 19, 20, 21, 22, 23, 24]
    * *Sub-divided into 2 rows:*
        * Row M2 (the net area): 21, 22, 23, 24
        * Row M1: 17, 18, 19, 20
* **Mid Court (中排 - Midfield):** Zones [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    * *Sub-divided into 3 rows:*
        * Row M3 (Front-Mid): 13, 14, 15, 16
        * Row M2: 9, 10, 11, 12
        * Row M1 (Back-Mid): 5, 6, 7, 8
* **Back Court (後排 - Baseline Area):** Zones [1, 2, 3, 4]
    * *Defensive area, clears and smashes originate here.*
* **Out of Bounds (出界區域):**
    * Left Flank (Left Side Out): 31 (Bottom), 30 (Mid), 29 (Top)
    * Right Flank (Right Side Out): 27 (Bottom), 26 (Mid), 25 (Top)
    * Rear Out (Behind Baseline): 32 (Left-Back), 28 (Right-Back)

## 2. Spatial Relationships (The Grid Matrix)
Imagine the court as a Matrix where Row 1 is the back (baseline) and Row 6 is the front (net).
Columns go from Left (A) to Right (D).

| Row/Col | Col A (Left) | Col B (Center-Left) | Col C (Center-Right) | Col D (Right) |
| :--- | :---: | :---: | :---: | :---: |
| **Row 6 (Front)** | 21 | 22 | 23 | 24 |
| **Row 5 (Front)** | 17 | 18 | 19 | 20 |
| **Row 4 (Mid)** | 13 | 14 | 15 | 16 |
| **Row 3 (Mid)** | 9 | 10 | 11 | 12 |
| **Row 2 (Mid)** | 5 | 6 | 7 | 8 |
| **Row 1 (Back)** | 1 | 2 | 3 | 4 |

*Note: Zones 29-31 are to the left of Col A. Zones 25-27 are to the right of Col D.*

## 3. Logic Rules for Analysis
1.  **Movement logic:** Moving from Zone 6 to Zone 10 is a "Forward" movement. Moving from 10 to 6 is "Backward".
2.  **Left/Right logic:** Zone 5 is "Left" of Zone 6. Zone 8 is the "Rightmost" in its row.
3.  **Adjacency:**
    * Zone 1 is adjacent to [2, 5, 31, 32].
    * Zone 14 is adjacent to [13, 15, 10, 18].
    * Zone 24 (Front-Right) is adjacent to [23, 20, 25].

# Task
When I provide a Zone ID, tell me its:
1.  **Category** (Front/Mid/Back/Out)
2.  **Relative Position** (e.g., Front-Left, Mid-Center)

    
**最佳實踐:**
    1. 區分連續數值(Float)與類別。座標勿直接 groupby。
    2. 軸標籤避免大量浮點數。
    3. 繪圖前檢查 `if len(filtered_df) > 0:`。
    
  <USER>
分析周天成所有殺球的落點，並繪製熱區圖。
  <ASSISTANT>
```python
import platform
import matplotlib.pyplot as plt
import seaborn as sns

# 字體設定
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False

# 篩選出周天成的殺球記錄
smash_df = df[(df['player'] == 'CHOU Tien Chen') & (df['type'] == '殺球')]

# 確認數據存在
if len(smash_df) > 0:
    # 統計每個區域的殺球落點數量
    landing_counts = smash_df['landing_area'].value_counts().sort_index()

    # 轉換區域代碼為熱區圖所需的格式
    grid_matrix = np.zeros((6, 4))
    for area, count in landing_counts.items():
        # 獲得區域的行列位置 (注意區域編碼從1開始)
        row = 6 - (area - 1) // 4
        col = (area - 1) % 4
        grid_matrix[row - 1, col] = count

    # 繪製熱區圖
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(grid_matrix, annot=True, fmt=".0f", cmap='Reds', ax=ax, cbar_kws={'label': '殺球次數'})
    ax.set_title('周天成殺球落點熱區圖')
    ax.set_xlabel('列 (從左到右)')
    ax.set_ylabel('行 (從後排到前排)')
    ax.set_yticklabels(['後排', '中排3', '中排2', '中排1', '前排2', '前排1'], rotation=0)
    ax.set_xticklabels(['左', '中左', '中右', '右'])
    plt.tight_layout()
else:
    print("周天成沒有任何殺球記錄。")
```
  <USER>
執行上述程式碼時發生錯誤: name 'np' is not defined。請修正錯誤並重新輸出完整程式碼 (包含必要的 import)。

[Output Response]:
抱歉遺漏了對 NumPy 的 import。讓我們修正該錯誤並提供完整的程式碼。

```python
import platform
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# 字體設定
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False

# 篩選出周天成的殺球記錄
smash_df = df[(df['player'] == 'CHOU Tien Chen') & (df['type'] == '殺球')]

# 確認數據存在
if len(smash_df) > 0:
    # 統計每個區域的殺球落點數量
    landing_counts = smash_df['landing_area'].value_counts().sort_index()

    # 轉換區域代碼為熱區圖所需的格式
    grid_matrix = np.zeros((6, 4))
    for area, count in landing_counts.items():
        # 獲得區域的行列位置 (注意區域編碼從1開始)
        row = 6 - (area - 1) // 4
        col = (area - 1) % 4
        grid_matrix[row - 1, col] = count

    # 繪製熱區圖
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(grid_matrix, annot=True, fmt=".0f", cmap='Reds', ax=ax, cbar_kws={'label': '殺球次數'})
    ax.set_title('周天成殺球落點熱區圖')
    ax.set_xlabel('列 (從左到右)')
    ax.set_ylabel('行 (從後排到前排)')
    ax.set_yticklabels(['後排', '中排3', '中排2', '中排1', '前排2', '前排1'], rotation=0)
    ax.set_xticklabels(['左', '中左', '中右', '右'])
    plt.tight_layout()
else:
    print("周天成沒有任何殺球記錄。")
```

解釋: 此程式碼包含對 `NumPy` 的 import，修正了之前遺漏的部分。接著，我們篩選出周天成的殺球數據，並計算每個落地區域的頻次，然後繪製相關的熱區圖顯示在哪些區域最多殺球。
==============================

==============================
[2025-12-17 10:04:15] Step: Step 3: Error Fix (Retry 2)
------------------------------
[Input Messages]:
  <SYSTEM>

你是一位羽球數據科學家，任務是分析 pandas DataFrame `df` 並生成 Python 程式碼解決問題，你必須對齊人類的常見邏輯，必要時可新增欄位方便撰寫程式碼，請一步步地思考後再撰寫程式碼。

**規則:**
1. IMPORTANT: 若使用的欄位是代碼，必須圖表中加入圖例(如:"player_type": ，"landing_area"...)
2. 分清楚三種狀態: 主動(得失分)、被動(得失分)或兩者皆有
3. 用 `matplotlib`/`seaborn` 繪圖，最後必須產生 `fig` 物件。勿用 `plt.show()`，且必須確保圖上所有元素不重疊使用(plt.tight_layout())。
4. 勿讀檔 (`df` 已存在)。
5. 計算前驗證數據 (如 `len(df) > 0`)。
6. 類別用名稱。Schema 字串需精確。
7. 用繁體中文。
8. 避免圖表資訊過載 (Information Overload)，保持圖表清晰易讀。
9. 圖表大小、文字與圖片搭配的視覺化需符合常見的圖表展示方式。
10. 若是畫長條圖，可以進行排序，增加識別性。
11. 可使用print()印出重要數值與精簡說明數值意義
11. 若使用 `player_type` 或 `opponent_type` 繪圖，**必須**在輸出中附上數值與名稱的'shot_types'對照表，以便使用者查閱。
12. 若使用area的欄位繪圖(如:player_location_area、landing_area......)，需給予使用者Court Grid Definitions中的Spatial Relationships Matrix
**數據:**
Schema:
[欄位詳細分析報告]
============================================================
### 欄位 'rally'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 42
### 欄位 'ball_round'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 46
### 欄位 'time'- 型態: object- 缺失值: 0% (無缺失)
### 欄位 'frame_num'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 11467.0, 最大值 = 135576.0
### 欄位 'score_status'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -11.0, 最大值 = 10.0
### 欄位 'player_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'opponent_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'player'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'server'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 3.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'type'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['發短球', '長球', '推撲球', '殺球', '接殺防守', '平球', '網前球', '挑球', '切球', '發長球']
### 欄位 'aroundhead'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(0.0), np.float64(1.0)]
### 欄位 'backhand'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(1.0), np.float64(0.0)]
### 欄位 'hit_height'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(2.0), np.float64(1.0)]
### 欄位 'hit_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 24.0
### 欄位 'hit_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7072498108502996, 最大值 = 0.7172898912180071
### 欄位 'hit_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.3553514469433116, 最大值 = 0.9998418761946708
### 欄位 'landing_height'- 型態: float64- ⚠️ 缺失值: 1.90% (99 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(1.0), np.float64(2.0), np.float64(nan)]
### 欄位 'landing_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 33.0
### 欄位 'landing_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.4798500180699032, 最大值 = 1.5145902614586062
### 欄位 'landing_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.5002113337896239, 最大值 = 0.9998418761946708
### 欄位 'lose_reason'- 型態: object- ⚠️ 缺失值: 94.73% (4930 筆)- 唯一值內容: [nan, '出界', '未過網', '掛網', '落點判斷失誤', '犯規']
### 欄位 'win_reason'- 型態: object- ⚠️ 缺失值: 97.18% (5057 筆)- 唯一值內容: [nan, '落地致勝', '落地判斷失誤']
### 欄位 'getpoint_player'- 型態: object- ⚠️ 缺失值: 91.89% (4782 筆)- 唯一值內容: [nan, 'Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'flaw'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'player_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'player_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'player_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'player_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'player_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'opponent_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'opponent_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'opponent_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'opponent_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'opponent_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'ball_distance'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.5661524051776352
### 欄位 'player_type'- 型態: float64- ⚠️ 缺失值: 2.57% (134 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 10.0- 唯一值內容: [np.float64(1.0), np.float64(nan), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(7.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'opponent_type'- 型態: float64- ⚠️ 缺失值: 2.59% (135 筆)- 數值範圍: 最小值 = 0.0, 最大值 = 10.0- 唯一值內容: [np.float64(0.0), np.float64(nan), np.float64(1.0), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(7.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'player_move_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'moving_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'moving_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.999696833101426
### 欄位 'landing_court_number'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'ball_distance_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1092144644472903, 最大值 = 1.330757215969243
### 欄位 'ball_distance_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.13632535323407, 最大值 = 1.2416487645230831
### 欄位 'db'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 0.0- 唯一值內容: [np.float64(0.0)]
### 欄位 'set'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 3- 唯一值內容: [np.int64(1), np.int64(2), np.int64(3)]
### 欄位 'match_id'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 7.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(5.0), np.float64(6.0), np.float64(7.0)]
### 欄位 'rally_id'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0, 最大值 = 475
### 欄位 'opponent'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['CHOU Tien Chen', 'Kento MOMOTA']
定義:
## 比賽資料結構
- Description: 羽球比賽數據欄位定義
- Structure: 三戰兩勝制, 21分制。⚠️ 每局決勝分未記錄，贏家分數需+1。

## 球種代碼對照表
- 1: 發短球
- 2: 發長球
- 3: 長球
- 4: 殺球
- 5: 切球
- 6: 挑球
- 7: 平球
- 8: 網前球
- 9: 推撲球
- 10: 接殺防守
- 11: 接不到

## 欄位定義
### `match_id`: 比賽 ID。用來區分不同的比賽場次。
### `set`: 局數。每場刷新。
### `rally`: 從發球開始到死球結束稱為一個 Rally。這是該局的第幾個 Rally。每局刷新。
- **Usage**: 跨局需配match_id, set。總回合: df.groupby(['match_id', 'set', 'rally']).ngroups
### `rally_id`: 整個數據集中唯一的回合 ID
### `ball_round`: 這是一個 Rally 中的第幾拍。發球是第 1 拍，接發球是第 2 拍，以此類推。
- **Usage**: 若要觀察對手回球、輸球原因等，可使用df['其他特定欄位'].shift()獲取前後拍的資訊
### `player`: 擊球球員姓名
- **Note**: 每個rally中雙方交替擊球
- **Usage**: 與多數欄位同時使用，代表player的各種情況。例如:(df['player']=='Player A' & df['type']=='殺球') -> Player A的殺球
### `opponent`: 對手球員姓名
- **Note**: 每個rally中雙方交替擊球
### `type`: 該球player打出的球種名稱(中文)
- **Note**: 參照shot_types
- **Usage**: 可使用df['type'].shift()獲取前後拍的球種
### `player_type`: 該球player打出的球種代碼
- **Mapping**: 1-11 (見shot_types)
- **Usage**: 若需要對手如何回擊player，參考下一筆的player_type，但必須確保在同個rally中
### `opponent_type`: 等價於該rally前一筆的player_type
- **Mapping**: 1-11 (見shot_types)
- **Note**: 不等價於opponent的回擊球種代碼
### `getpoint_player`: 該回合得分者，若正在打球過程
- **Usage**: group by set/rally取last()，同時欄位有NULL存在，必要時可使用dropna()
- **Important**: 此欄位有三種狀況: player主動得分、player主動失分(當opponent == getpoint_player)與player未得分也未失分(當getpoint_ player==NULL)。
- **Note**: getpoint_player != player不代表player失分，getpoint_player == opponent才代表player失分。
### `hit_x`: player擊球點X座標
### `hit_y`: player擊球點Y座標
### `hit_area`: player擊球點所在區域代碼 (1-32)
### `landing_x`: 球的落點X座標，可視為下顆球對方的擊球點X座標
### `landing_y`: 球的落點Y座標，可視為下顆球對方的擊球點Y座標
### `landing_area`: 球的落點區域代碼 (1-32)(即為下顆球對方的擊球點區域代碼)
### `player_location_x`: 球員所站點的 X 座標。
### `player_location_y`: 球員所站點的 Y 座標。
### `player_location_area`: 球員所站點的區域代碼。
### `player_move_x`: 擊球點到移動位置的X座標位移量。(moving_x-hit_x)
### `player_move_y`: 擊球點到移動位置的Y座標位移量。(moving_y-hit_y)
### `moving_x`: 球員擊完這一球後，移動到的X座標。
### `moving_y`: 球員擊完這一球後，移動到的Y座標。
### `player_moving_area`: 球員擊完這一球後，移動到的區域代碼
### `opponent_location_x`: 對手所站的位置X座標
### `opponent_location_y`: 對手所站的位置Y座標
### `opponent_location_area`: 對手擊球區域。對手所站的位置區域代碼
### `opponent_move_x`: 對手擊球點到移動位置的X座標位移量。
### `opponent_move_y`: 對手擊球點到移動位置的Y座標位移量。
### `ball_distance`: 飛行距離。球從擊球點 (hit) 到落點 (landing) 的直線距離。

## 分析指南
{
  "core": "使用 `getpoint_player` (Event) 統計得分，勿用 `player_score` (State) 加總。",
  "rally_count": "df.groupby(['match_id', 'set', 'rally']).ngroups",
  "winning_logic": {
    "active": "球員(P1)擊球得分: `df[(df['getpoint_player'] == 'P1') & (df['player'] == 'P1')]`",
    "passive": "球員(P1)對手失誤: `df[(df['getpoint_player'] == 'P1') & (df['player'] != 'P1')]`"
  },
  "win_rate": "1.GroupBy Rally取 getpoint_player 2.Sum Wins 3.Divide by total rallies",
  "shot_analysis": {
    "group": "用 `player_type` (數字代碼)",
    "logic": "分析「特定球種得分」時，必須篩選 `player == getpoint_player` (Active Win)。"
  },
  "match_score": "找出每局最後一筆分數，贏家+1。",
  "continuous_play": "回球查詢應用: `iloc` + `index + 1`，注意對手回球是在下一列。"
}

2. **邏輯判斷 (CRITICAL)**:
   - **善用工具箱 (Badminton Toolkit)**: 環境中已預載 `lib` 模組 (from utils import badminton_lib as lib)。**這比你自己寫 Pandas 更準確且省 Token，請優先使用。謹慎注意傳入與回傳的形式**
     - **WARNING**: 呼叫 `lib` 函數時，請務必傳入**完整 DataFrame (df)**，**切勿**先篩選欄位 (e.g., `df[['col1', 'col2']]`)，以免缺少必要欄位導致錯誤。
     - `lib.get_shot_context(df, shift_n=1)`: 獲取前後 N 拍資訊，處理時序分析。輸入 某欄位的DataFrame 與位移量 (+1=setup, -1=response)，回傳含有 suffix 欄位的新 DataFrame。
     - `lib.filter_active_win(df)`: 篩選球員主動得分的回合，排除對手失誤。輸入 DataFrame，回傳過濾後的主動得分 DataFrame。
     - `lib.merge_small_slices(series)`: 合併圓餅圖中佔比過小的區塊。輸入 Series，回傳合併小區塊為「其他」後的 Series。
     - `lib.classify_area(zone_id)`: 將 1-32 的落點代碼轉換為四大場地區域。輸入 Zone ID，回傳前場/中場/後場/出界標籤。
     - `lib.get_win_loss_reason_counts(df, player_name)`: 統計特定球員的得分與失分原因。輸入 DataFrame 與球員名稱，回傳得分原因與失分原因兩個 Series。
     - `lib.get_rally_flow(df, match_id, set_num, rally_id)`: 取得特定 Rally 的完整擊球流程。輸入 Match/Set/Rally ID，回傳依照擊球順序排序的 DataFrame。
     - `lib.get_zones_by_area(area_name)`: 轉換中文場地描述為 Zone ID 列表。輸入區域描述 (如 "前後場")，回傳對應的 Zone ID List (list[int])。

   - **時序分析 (Temporal Analysis)**:
     - 務必使用 `lib.get_shot_context(df, n)`，除特殊情況外，**不要自己寫** `groupby().shift()`。
     - 使用範例:
       ```python
       # 分析周天成殺球後，對手與下一拍的反應
       df_prev = lib.get_shot_context(df, shift_n=-1) 
       df_smash = df_prev[(df_prev['player'] == 'CHOU Tien Chen') & (df_prev['type'] == '殺球')]
       # 分析對手下一拍回球: 欄位變成 'type_next1'
       print(df_smash['type_next1'].value_counts())
       ```
   - IMPORTANT: 主客關係邏輯務必清晰。若該球player='玩家A'為主opponent='玩家A的對手'為客，下一球player='玩家A的對手'為主opponent='玩家A'為客，輪流交替。

3. **視覺化 (Matplotlib/Seaborn)**:
   - 繪製圓餅圖 (Pie Chart) 時，**必須** 使用 `lib.merge_small_slices(data)` 處理數據。
   - 用最適合解決問題的視覺畫圖表呈現(考慮視覺效果，讓圖表更好讀)
   - 必須產生 `fig` 物件，**勿用** `plt.show()`。使用 `plt.tight_layout()` 確保不重疊。
   - 避免資訊過載 (Information Overload)：長條圖可排序/取 Top N；圖表文字需清晰且符合常見展示方式。
   - 若欄位為代碼 (如 `player_type`)，**必須**在圖表中加入圖例。
   - **IMPORTANT**: 不限畫單一圖表，可繪製多張圖表。
   - 「繪圖數據」與「標籤數據」須確保一致。
   - 謹慎使用堆疊長條圖。
   - IMPORTANT: 用繁體中文的圖表標籤

4. **字體設定 (程式碼開頭必寫)**:
```python
import platform
import matplotlib.pyplot as plt
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False
```

**回覆模式 (Strict Format)**:
1. **PLAN 區塊** (必填): 先列出解題邏輯點列 (Pseudocode)，確保邏輯正確。
   e.g.
   PLAN:
   1. Filter data by player...
   2. Use lib.get_shot_context(shift=-1)...
   3. Group by type and count...
2. **PYTHON CODE 區塊**: 接著才是 Python 程式碼。
3. **解釋**: 最後可視情況補充說明。

**回覆範例**:
PLAN:
1. ...
```python
...
```
解釋: ...

**數據 Schema:**
[欄位詳細分析報告]
============================================================
### 欄位 'rally'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 42
### 欄位 'ball_round'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 46
### 欄位 'time'- 型態: object- 缺失值: 0% (無缺失)
### 欄位 'frame_num'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 11467.0, 最大值 = 135576.0
### 欄位 'score_status'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -11.0, 最大值 = 10.0
### 欄位 'player_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'opponent_score'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 21.0
### 欄位 'player'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'server'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 3.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'type'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['發短球', '長球', '推撲球', '殺球', '接殺防守', '平球', '網前球', '挑球', '切球', '發長球']
### 欄位 'aroundhead'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(0.0), np.float64(1.0)]
### 欄位 'backhand'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.0- 唯一值內容: [np.float64(1.0), np.float64(0.0)]
### 欄位 'hit_height'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(2.0), np.float64(1.0)]
### 欄位 'hit_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 24.0
### 欄位 'hit_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7072498108502996, 最大值 = 0.7172898912180071
### 欄位 'hit_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.3553514469433116, 最大值 = 0.9998418761946708
### 欄位 'landing_height'- 型態: float64- ⚠️ 缺失值: 1.90% (99 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 2.0- 唯一值內容: [np.float64(1.0), np.float64(2.0), np.float64(nan)]
### 欄位 'landing_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 33.0
### 欄位 'landing_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.4798500180699032, 最大值 = 1.5145902614586062
### 欄位 'landing_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.5002113337896239, 最大值 = 0.9998418761946708
### 欄位 'lose_reason'- 型態: object- ⚠️ 缺失值: 94.73% (4930 筆)- 唯一值內容: [nan, '出界', '未過網', '掛網', '落點判斷失誤', '犯規']
### 欄位 'win_reason'- 型態: object- ⚠️ 缺失值: 97.18% (5057 筆)- 唯一值內容: [nan, '落地致勝', '落地判斷失誤']
### 欄位 'getpoint_player'- 型態: object- ⚠️ 缺失值: 91.89% (4782 筆)- 唯一值內容: [nan, 'Kento MOMOTA', 'CHOU Tien Chen']
### 欄位 'flaw'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'player_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'player_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'player_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'player_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'player_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'opponent_location_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'opponent_location_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'opponent_location_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.95971952599695
### 欄位 'opponent_move_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1697412471298043, 最大值 = 0.85737314225558
### 欄位 'opponent_move_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.9252298615080254, 最大值 = 0.5127036515604619
### 欄位 'ball_distance'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 1.5661524051776352
### 欄位 'player_type'- 型態: float64- ⚠️ 缺失值: 2.57% (134 筆)- 數值範圍: 最小值 = 1.0, 最大值 = 10.0- 唯一值內容: [np.float64(1.0), np.float64(nan), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(7.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'opponent_type'- 型態: float64- ⚠️ 缺失值: 2.59% (135 筆)- 數值範圍: 最小值 = 0.0, 最大值 = 10.0- 唯一值內容: [np.float64(0.0), np.float64(nan), np.float64(1.0), np.float64(9.0), np.float64(4.0), np.float64(10.0), np.float64(8.0), np.float64(6.0), np.float64(5.0), np.float64(7.0), np.float64(3.0), np.float64(2.0)]
### 欄位 'player_move_area'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 32.0
### 欄位 'moving_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.7837007613539037, 最大值 = 0.7650948897725632
### 欄位 'moving_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -0.4370338007902143, 最大值 = 0.999696833101426
### 欄位 'landing_court_number'- 型態: float64- ⚠️ 缺失值: 100.00% (5204 筆)- 數值範圍: 最小值 = nan, 最大值 = nan- 唯一值內容: [np.float64(nan)]
### 欄位 'ball_distance_x'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.1092144644472903, 最大值 = 1.330757215969243
### 欄位 'ball_distance_y'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = -1.13632535323407, 最大值 = 1.2416487645230831
### 欄位 'db'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0.0, 最大值 = 0.0- 唯一值內容: [np.float64(0.0)]
### 欄位 'set'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1, 最大值 = 3- 唯一值內容: [np.int64(1), np.int64(2), np.int64(3)]
### 欄位 'match_id'- 型態: float64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 1.0, 最大值 = 7.0- 唯一值內容: [np.float64(1.0), np.float64(3.0), np.float64(5.0), np.float64(6.0), np.float64(7.0)]
### 欄位 'rally_id'- 型態: int64- 缺失值: 0% (無缺失)- 數值範圍: 最小值 = 0, 最大值 = 475
### 欄位 'opponent'- 型態: object- 缺失值: 0% (無缺失)- 唯一值內容: ['CHOU Tien Chen', 'Kento MOMOTA']

**欄位定義:**
## 比賽資料結構
- Description: 羽球比賽數據欄位定義
- Structure: 三戰兩勝制, 21分制。⚠️ 每局決勝分未記錄，贏家分數需+1。

## 球種代碼對照表
- 1: 發短球
- 2: 發長球
- 3: 長球
- 4: 殺球
- 5: 切球
- 6: 挑球
- 7: 平球
- 8: 網前球
- 9: 推撲球
- 10: 接殺防守
- 11: 接不到

## 欄位定義
### `match_id`: 比賽 ID。用來區分不同的比賽場次。
### `set`: 局數。每場刷新。
### `rally`: 從發球開始到死球結束稱為一個 Rally。這是該局的第幾個 Rally。每局刷新。
- **Usage**: 跨局需配match_id, set。總回合: df.groupby(['match_id', 'set', 'rally']).ngroups
### `rally_id`: 整個數據集中唯一的回合 ID
### `ball_round`: 這是一個 Rally 中的第幾拍。發球是第 1 拍，接發球是第 2 拍，以此類推。
- **Usage**: 若要觀察對手回球、輸球原因等，可使用df['其他特定欄位'].shift()獲取前後拍的資訊
### `player`: 擊球球員姓名
- **Note**: 每個rally中雙方交替擊球
- **Usage**: 與多數欄位同時使用，代表player的各種情況。例如:(df['player']=='Player A' & df['type']=='殺球') -> Player A的殺球
### `opponent`: 對手球員姓名
- **Note**: 每個rally中雙方交替擊球
### `type`: 該球player打出的球種名稱(中文)
- **Note**: 參照shot_types
- **Usage**: 可使用df['type'].shift()獲取前後拍的球種
### `player_type`: 該球player打出的球種代碼
- **Mapping**: 1-11 (見shot_types)
- **Usage**: 若需要對手如何回擊player，參考下一筆的player_type，但必須確保在同個rally中
### `opponent_type`: 等價於該rally前一筆的player_type
- **Mapping**: 1-11 (見shot_types)
- **Note**: 不等價於opponent的回擊球種代碼
### `getpoint_player`: 該回合得分者，若正在打球過程
- **Usage**: group by set/rally取last()，同時欄位有NULL存在，必要時可使用dropna()
- **Important**: 此欄位有三種狀況: player主動得分、player主動失分(當opponent == getpoint_player)與player未得分也未失分(當getpoint_ player==NULL)。
- **Note**: getpoint_player != player不代表player失分，getpoint_player == opponent才代表player失分。
### `hit_x`: player擊球點X座標
### `hit_y`: player擊球點Y座標
### `hit_area`: player擊球點所在區域代碼 (1-32)
### `landing_x`: 球的落點X座標，可視為下顆球對方的擊球點X座標
### `landing_y`: 球的落點Y座標，可視為下顆球對方的擊球點Y座標
### `landing_area`: 球的落點區域代碼 (1-32)(即為下顆球對方的擊球點區域代碼)
### `player_location_x`: 球員所站點的 X 座標。
### `player_location_y`: 球員所站點的 Y 座標。
### `player_location_area`: 球員所站點的區域代碼。
### `player_move_x`: 擊球點到移動位置的X座標位移量。(moving_x-hit_x)
### `player_move_y`: 擊球點到移動位置的Y座標位移量。(moving_y-hit_y)
### `moving_x`: 球員擊完這一球後，移動到的X座標。
### `moving_y`: 球員擊完這一球後，移動到的Y座標。
### `player_moving_area`: 球員擊完這一球後，移動到的區域代碼
### `opponent_location_x`: 對手所站的位置X座標
### `opponent_location_y`: 對手所站的位置Y座標
### `opponent_location_area`: 對手擊球區域。對手所站的位置區域代碼
### `opponent_move_x`: 對手擊球點到移動位置的X座標位移量。
### `opponent_move_y`: 對手擊球點到移動位置的Y座標位移量。
### `ball_distance`: 飛行距離。球從擊球點 (hit) 到落點 (landing) 的直線距離。

## 分析指南
{
  "core": "使用 `getpoint_player` (Event) 統計得分，勿用 `player_score` (State) 加總。",
  "rally_count": "df.groupby(['match_id', 'set', 'rally']).ngroups",
  "winning_logic": {
    "active": "球員(P1)擊球得分: `df[(df['getpoint_player'] == 'P1') & (df['player'] == 'P1')]`",
    "passive": "球員(P1)對手失誤: `df[(df['getpoint_player'] == 'P1') & (df['player'] != 'P1')]`"
  },
  "win_rate": "1.GroupBy Rally取 getpoint_player 2.Sum Wins 3.Divide by total rallies",
  "shot_analysis": {
    "group": "用 `player_type` (數字代碼)",
    "logic": "分析「特定球種得分」時，必須篩選 `player == getpoint_player` (Active Win)。"
  },
  "match_score": "找出每局最後一筆分數，贏家+1。",
  "continuous_play": "回球查詢應用: `iloc` + `index + 1`，注意對手回球是在下一列。"
}


**場地位置參考資訊 (Court Grid Definitions):**
# Role Definition
You are an expert Badminton Tactical Analyst. You interpret court positions based on a specific discretized grid layout of a half-court.

# Court Grid Definitions
The badminton half-court is divided into a grid system with specific Zone IDs (1-32).

## 1. Zone Categories (Semantic Layers)
* **Front Court (前排 - Net Area):** Zones [17, 18, 19, 20, 21, 22, 23, 24]
    * *Sub-divided into 2 rows:*
        * Row M2 (the net area): 21, 22, 23, 24
        * Row M1: 17, 18, 19, 20
* **Mid Court (中排 - Midfield):** Zones [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    * *Sub-divided into 3 rows:*
        * Row M3 (Front-Mid): 13, 14, 15, 16
        * Row M2: 9, 10, 11, 12
        * Row M1 (Back-Mid): 5, 6, 7, 8
* **Back Court (後排 - Baseline Area):** Zones [1, 2, 3, 4]
    * *Defensive area, clears and smashes originate here.*
* **Out of Bounds (出界區域):**
    * Left Flank (Left Side Out): 31 (Bottom), 30 (Mid), 29 (Top)
    * Right Flank (Right Side Out): 27 (Bottom), 26 (Mid), 25 (Top)
    * Rear Out (Behind Baseline): 32 (Left-Back), 28 (Right-Back)

## 2. Spatial Relationships (The Grid Matrix)
Imagine the court as a Matrix where Row 1 is the back (baseline) and Row 6 is the front (net).
Columns go from Left (A) to Right (D).

| Row/Col | Col A (Left) | Col B (Center-Left) | Col C (Center-Right) | Col D (Right) |
| :--- | :---: | :---: | :---: | :---: |
| **Row 6 (Front)** | 21 | 22 | 23 | 24 |
| **Row 5 (Front)** | 17 | 18 | 19 | 20 |
| **Row 4 (Mid)** | 13 | 14 | 15 | 16 |
| **Row 3 (Mid)** | 9 | 10 | 11 | 12 |
| **Row 2 (Mid)** | 5 | 6 | 7 | 8 |
| **Row 1 (Back)** | 1 | 2 | 3 | 4 |

*Note: Zones 29-31 are to the left of Col A. Zones 25-27 are to the right of Col D.*

## 3. Logic Rules for Analysis
1.  **Movement logic:** Moving from Zone 6 to Zone 10 is a "Forward" movement. Moving from 10 to 6 is "Backward".
2.  **Left/Right logic:** Zone 5 is "Left" of Zone 6. Zone 8 is the "Rightmost" in its row.
3.  **Adjacency:**
    * Zone 1 is adjacent to [2, 5, 31, 32].
    * Zone 14 is adjacent to [13, 15, 10, 18].
    * Zone 24 (Front-Right) is adjacent to [23, 20, 25].

# Task
When I provide a Zone ID, tell me its:
1.  **Category** (Front/Mid/Back/Out)
2.  **Relative Position** (e.g., Front-Left, Mid-Center)

    
**最佳實踐:**
    1. 區分連續數值(Float)與類別。座標勿直接 groupby。
    2. 軸標籤避免大量浮點數。
    3. 繪圖前檢查 `if len(filtered_df) > 0:`。
    
  <USER>
分析周天成所有殺球的落點，並繪製熱區圖。
  <ASSISTANT>
```python
import platform
import matplotlib.pyplot as plt
import seaborn as sns

# 字體設定
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False

# 篩選出周天成的殺球記錄
smash_df = df[(df['player'] == 'CHOU Tien Chen') & (df['type'] == '殺球')]

# 確認數據存在
if len(smash_df) > 0:
    # 統計每個區域的殺球落點數量
    landing_counts = smash_df['landing_area'].value_counts().sort_index()

    # 轉換區域代碼為熱區圖所需的格式
    grid_matrix = np.zeros((6, 4))
    for area, count in landing_counts.items():
        # 獲得區域的行列位置 (注意區域編碼從1開始)
        row = 6 - (area - 1) // 4
        col = (area - 1) % 4
        grid_matrix[row - 1, col] = count

    # 繪製熱區圖
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(grid_matrix, annot=True, fmt=".0f", cmap='Reds', ax=ax, cbar_kws={'label': '殺球次數'})
    ax.set_title('周天成殺球落點熱區圖')
    ax.set_xlabel('列 (從左到右)')
    ax.set_ylabel('行 (從後排到前排)')
    ax.set_yticklabels(['後排', '中排3', '中排2', '中排1', '前排2', '前排1'], rotation=0)
    ax.set_xticklabels(['左', '中左', '中右', '右'])
    plt.tight_layout()
else:
    print("周天成沒有任何殺球記錄。")
```
  <USER>
執行上述程式碼時發生錯誤: name 'np' is not defined。請修正錯誤並重新輸出完整程式碼 (包含必要的 import)。
  <ASSISTANT>
```python
import platform
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# 字體設定
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False

# 篩選出周天成的殺球記錄
smash_df = df[(df['player'] == 'CHOU Tien Chen') & (df['type'] == '殺球')]

# 確認數據存在
if len(smash_df) > 0:
    # 統計每個區域的殺球落點數量
    landing_counts = smash_df['landing_area'].value_counts().sort_index()

    # 轉換區域代碼為熱區圖所需的格式
    grid_matrix = np.zeros((6, 4))
    for area, count in landing_counts.items():
        # 獲得區域的行列位置 (注意區域編碼從1開始)
        row = 6 - (area - 1) // 4
        col = (area - 1) % 4
        grid_matrix[row - 1, col] = count

    # 繪製熱區圖
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(grid_matrix, annot=True, fmt=".0f", cmap='Reds', ax=ax, cbar_kws={'label': '殺球次數'})
    ax.set_title('周天成殺球落點熱區圖')
    ax.set_xlabel('列 (從左到右)')
    ax.set_ylabel('行 (從後排到前排)')
    ax.set_yticklabels(['後排', '中排3', '中排2', '中排1', '前排2', '前排1'], rotation=0)
    ax.set_xticklabels(['左', '中左', '中右', '右'])
    plt.tight_layout()
else:
    print("周天成沒有任何殺球記錄。")
```
  <USER>
執行上述程式碼時發生錯誤: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices。請修正錯誤並重新輸出完整程式碼 (包含必要的 import)。

[Output Response]:
```python
import platform
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# 字體設定
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False

# 篩選出周天成的殺球記錄
smash_df = df[(df['player'] == 'CHOU Tien Chen') & (df['type'] == '殺球')]

# 確認數據存在
if len(smash_df) > 0:
    # 統計每個區域的殺球落點數量
    landing_counts = smash_df['landing_area'].value_counts().sort_index()

    # 轉換區域代碼為熱區圖所需的格式
    grid_matrix = np.zeros((6, 4))
    # Handling the 'landing_area' which ranges from 1 to 32
    for area, count in landing_counts.items():
        if 1 <= area <= 32:
            # Translate area to matrix position
            if area <= 24: # Valid playing zones
                row = 6 - (area - 1) // 4
                col = (area - 1) % 4
                grid_matrix[int(row) - 1, int(col)] += count

    # 繪製熱區圖
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(grid_matrix, annot=True, fmt=".0f", cmap='Reds', ax=ax, cbar_kws={'label': '殺球次數'})
    ax.set_title('周天成殺球落點熱區圖')
    ax.set_xlabel('列 (從左到右)')
    ax.set_ylabel('行 (從後排到前排)')
    ax.set_yticklabels(['後排', '中排3', '中排2', '中排1', '前排2', '前排1'], rotation=0)
    ax.set_xticklabels(['左', '中左', '中右', '右'])
    plt.tight_layout()
else:
    print("周天成沒有任何殺球記錄。")
```
==============================

==============================
[2025-12-17 10:04:26] Step: Step 4: Logic Reflection
------------------------------
[Input Messages]:
  <USER>

    [查核資料]
    1. 問題: "針對周天成所有「殺球」，繪製其落點熱區圖。"
    2. 程式碼:
    ```python
    import platform
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# 字體設定
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False

# 篩選出周天成的殺球記錄
smash_df = df[(df['player'] == 'CHOU Tien Chen') & (df['type'] == '殺球')]

# 確認數據存在
if len(smash_df) > 0:
    # 統計每個區域的殺球落點數量
    landing_counts = smash_df['landing_area'].value_counts().sort_index()

    # 轉換區域代碼為熱區圖所需的格式
    grid_matrix = np.zeros((6, 4))
    # Handling the 'landing_area' which ranges from 1 to 32
    for area, count in landing_counts.items():
        if 1 <= area <= 32:
            # Translate area to matrix position
            if area <= 24: # Valid playing zones
                row = 6 - (area - 1) // 4
                col = (area - 1) % 4
                grid_matrix[int(row) - 1, int(col)] += count

    # 繪製熱區圖
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(grid_matrix, annot=True, fmt=".0f", cmap='Reds', ax=ax, cbar_kws={'label': '殺球次數'})
    ax.set_title('周天成殺球落點熱區圖')
    ax.set_xlabel('列 (從左到右)')
    ax.set_ylabel('行 (從後排到前排)')
    ax.set_yticklabels(['後排', '中排3', '中排2', '中排1', '前排2', '前排1'], rotation=0)
    ax.set_xticklabels(['左', '中左', '中右', '右'])
    plt.tight_layout()
else:
    print("周天成沒有任何殺球記錄。")
    ```
    3. 執行與變數: 
    _generated_figures_count: 1
s: Windows
smash_df: DataFrame/Series with 299 rows
landing_counts: DataFrame/Series with 23 rows
grid_matrix: [[ 1.  1.  2.  0.]
 [ 0.  1.  2.  0.]
 [10.  3.  8. 11.]
 [49. 32. 55. 60.]
 [20.  1.  5. 17.]
 [ 3.  0.  0.  2.]]
area: 31.0
count: 1
row: 1.0
col: 2.0


    你是嚴格的「程式碼邏輯審計員 (Code Auditor)」，察覺邏輯錯誤部分詳細思考如何修改。請檢查：
    IMPORTANT: 根據"問題"程式碼是否有誤，畫出的圖表是否符合問題要求
    
    判斷:
    - 🐛 潛在邏輯問題 (Bug Check):
        - [資料完整性]: 檢查變數覆蓋、dropna不當。
        - [資料合適性]: 檢查數值合併錯誤 (如Score求和)。
        - [統計聚合]: 檢查 groupby + sum/mean 合理性。
        - [欄位正確性]: 檢查欄位選用 (如 player vs getpoint_player)。
        - [上下文]: 結果是否回答問題。
        - [其他]: 任何潛在邏輯陷阱。
    - ❌ 無資料: 變數顯示 `Empty/0 rows` 或 `_generated_figures_count`=0 且無輸出 -> FAIL
    - ⚠️ 資訊過載 (Information Overload):
        - **圓餅圖**: 根據結果若有多於兩類別皆為極小比例(如 < 5%)，**必須**將小於閾值的類別合併為「其他 (Others)」，**嚴禁直接過濾刪除**。
        - **長條圖**: 根據結果若 X 軸標籤過多導致重疊，或X軸與Y軸邏輯搞相反，**必須**重新設計圖表。
    - ✅ 通過: 資料非空且有輸出/圖表清晰 -> PASS
    
    回覆: "PASS" 或 修正後的完整程式碼 (含 ```python)。
    

[Output Response]:
根據提供的程式碼和問題描述，程式碼的目的是繪製周天成所有「殺球」的落點熱區圖。從程式碼和執行結果來看，整體邏輯是正確的，並且生成了一個圖表 (`_generated_figures_count: 1`)。然而，程式碼中有一些潛在的改進空間，以確保更好的可讀性和準確性：

1. **區域代碼轉換**：目前的區域代碼轉換邏輯是基於假設區域代碼從1到32，但實際上只處理了1到24的區域。這可能會導致某些區域未被正確處理。需要確認這些區域代碼的定義是否正確。

2. **行列標籤**：目前的行列標籤可能會讓人混淆，因為它們是以「行」和「列」的方式描述，但實際上是「列」和「行」。這可能會導致誤解。

3. **資料完整性檢查**：在處理資料之前，應該檢查資料的完整性，例如是否有缺失值，並在必要時進行處理。

以下是改進後的程式碼：

```python
import platform
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# 字體設定
s = platform.system()
plt.rcParams['font.sans-serif'] = ['Arial Unicode MS', 'PingFang TC'] if s=='Darwin' else ['Microsoft JhengHei', 'SimHei'] if s=='Windows' else ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False

# 篩選出周天成的殺球記錄
smash_df = df[(df['player'] == 'CHOU Tien Chen') & (df['type'] == '殺球')]

# 確認數據存在
if len(smash_df) > 0:
    # 統計每個區域的殺球落點數量
    landing_counts = smash_df['landing_area'].value_counts().sort_index()

    # 轉換區域代碼為熱區圖所需的格式
    grid_matrix = np.zeros((6, 4))
    # Handling the 'landing_area' which ranges from 1 to 32
    for area, count in landing_counts.items():
        if 1 <= area <= 24: # Assuming valid playing zones are 1 to 24
            # Translate area to matrix position
            row = 6 - (area - 1) // 4
            col = (area - 1) % 4
            grid_matrix[int(row) - 1, int(col)] += count

    # 繪製熱區圖
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(grid_matrix, annot=True, fmt=".0f", cmap='Reds', ax=ax, cbar_kws={'label': '殺球次數'})
    ax.set_title('周天成殺球落點熱區圖')
    ax.set_xlabel('列 (從左到右)')
    ax.set_ylabel('行 (從後排到前排)')
    ax.set_yticklabels(['後排', '中排3', '中排2', '中排1', '前排2', '前排1'], rotation=0)
    ax.set_xticklabels(['左', '中左', '中右', '右'])
    plt.tight_layout()
else:
    print("周天成沒有任何殺球記錄。")
```

這段程式碼應該能夠正確地生成所需的熱區圖，並且更清晰地表達資料的意圖。
==============================

==============================
[2025-12-17 10:04:36] Step: Step 6: Insight Generation
------------------------------
[Input Messages]:
  <SYSTEM>
你是一位專業羽球教練與數據戰術大師。請針對使用者問題與核心數據結果，用教練的口吻撰寫精準的戰術洞察，提供有深度的分析，需精簡回答。
  <USER>

    你是羽球教練。問題: "針對周天成所有「殺球」，繪製其落點熱區圖。"
    數據:
    程式碼執行後，擷取出以下核心變數與其值：

### 變數 `s` (型別: `str`)
```
Windows
```

### 變數 `smash_df` (型別: `str`)
```
DataFrame/Series with 299 rows
```

### 變數 `landing_counts` (型別: `str`)
```
DataFrame/Series with 23 rows
```

### 變數 `grid_matrix` (型別: `ndarray`)
```
[[ 1.  1.  2.  0.]
 [ 0.  1.  2.  0.]
 [10.  3.  8. 11.]
 [49. 32. 55. 60.]
 [20.  1.  5. 17.]
 [ 3.  0.  0.  2.]]
```

### 變數 `area` (型別: `float`)
```
31.0
```

### 變數 `count` (型別: `int`)
```
1
```

### 變數 `row` (型別: `float`)
```
1.0
```

### 變數 `col` (型別: `float`)
```
2.0
```

### 變數 `_generated_figures_count` (型別: `int`)
```
1
```


    規定:
    1. 若圖表含 "player_type"/"opponent_type"，必須輸出 Mapping: 1:發短球, 2:發長球, 3:長球, 4:殺球, 5:切球, 6:挑球, 7:平球, 8:網前球, 9:推撲球, 10:接殺防守, 11:接不到。
    2. 若圖表含 "area" (landing_area...)，必須輸出:
| Row/Col | Col A (Left) | Col B (C-Left) | Col C (C-Right) | Col D (Right) |
| :--- | :---: | :---: | :---: | :---: |
| **Row 6 (Front)** | 21 | 22 | 23 | 24 |
| **Row 5 (Front)** | 17 | 18 | 19 | 20 |
| **Row 4 (Mid)** | 13 | 14 | 15 | 16 |
| **Row 3 (Mid)** | 9 | 10 | 11 | 12 |
| **Row 2 (Mid)** | 5 | 6 | 7 | 8 |
| **Row 1 (Back)** | 1 | 2 | 3 | 4 |

    用教練口吻，基於數據精簡提供戰術洞察。說明數字背後的意義，只說事實。
    

[Output Response]:
根據數據分析，周天成的殺球落點熱區集中在場地的中間和右側區域，尤其是第4行和第3行的落點最為密集。具體來說，第4行的右側區域（Col D）有60次落點，這顯示出他在這些區域的攻擊性非常強。

這樣的落點分佈表明周天成在殺球時，傾向於瞄準對手場地的中後段，特別是右側，這可能是因為他希望通過快速且有力的殺球來迫使對手後退，並利用對手的防守空檔進行進一步的進攻。

戰術上，這樣的殺球策略可以有效地壓制對手，特別是當對手的防守能力在這些區域較弱時。然而，也需要注意的是，這樣的攻擊模式可能會被對手預測，因此在比賽中需要適時變換落點，以增加對手的防守難度。

在訓練中，可以進一步強化在其他區域的殺球準確性，特別是左側區域，以增加戰術的多樣性和不可預測性。這將有助於提高整體比賽的靈活性和競爭力。
==============================
